[{"content":"WHAT IS PANDAS 聽到Pandas時你的反應是什麼? 熊貓?功夫熊貓?粉紅色外送平台? Pandas是一個在資料科學領域中非常重要的工具。 類似試算表的概念，是一個專門用來處理結構化數據的 Python 套件，尤其在資料分析上，會頻繁使用它來進行數據操作\nPandas 的出現是為了填補 Excel 或其他試算表工具的不足。 舉例來說，Excel 在處理大型數據集時常常會受到列數限制或處理效率的影響， 而 Pandas 則能輕鬆應對數百萬甚至上億行的數據。 Excel 雖然可以用 VBA 做一些自動化處理，但相較於程式語言，這種自動化的程度較低。\nPandas 不僅能進行靈活的數據操作，還可以和 Python 的其他工具（如 NumPy、scikit-learn、Matplotlib）整合，這使得我們可以進行完整的數據分析流程。\nStart Pandas\n會先需要安裝套件，安裝後import pandas 並命名為pd\n1 2 pip install pandas import pandas as pd 取pandas簡寫pd，但如果要很反骨的用其他方式命名也不是不行啦\u0026hellip; Pandas核心資料結構 Pandas 的核心結構有Series和DataFrame兩種 Series Series 是 Pandas 中的單維度數據結構，類似於一個帶有標籤的陣列。我們可以把它想像成 Excel 表格中的一列。每個數據值都有對應的索引，就像每個單元格都有標籤一樣。索引可以是數字（比如 0, 1, 2…），也可以是自定義標籤（比如姓名）。可以透過索引來檢索某一個特定的數據。 創建一個名為 s 的 Series，數據值是 31, 29, 24, 22，對應的索引是 \u0026lsquo;Anthony\u0026rsquo;, \u0026lsquo;Benedict\u0026rsquo;, \u0026lsquo;Collin\u0026rsquo;, \u0026lsquo;Daphne\u0026rsquo;。\n1 2 s = pd.Series([31,29,24,22] , index=[\u0026#39;Anthony\u0026#39;, \u0026#39;Benedict\u0026#39;, \u0026#39;Collin\u0026#39;, \u0026#39;Daphne\u0026#39;]) print(s) 輸出結果看起來就像是一個標籤和數據的對應關係。\n1 2 3 4 5 Anthony 31 Benedict 29 Collin 24 Daphne 22 dtype: int64 常見的 Series 操作\n選取數據：可以透過索引名稱或位置來選取數據。比如你可以選取 s[\u0026lsquo;Anthony\u0026rsquo;] 或 s[0]，兩者都會返回 31。\n1 2 print(s[\u0026#39;Anthony\u0026#39;]) # 選取索引 \u0026#39;Anthony\u0026#39; 的數據，結果為 31 print(s[0]) # 選取第一個數據，結果為 31 31\n31\n數據運算：Series 支援加減乘除等運算，你可以對整個 Series 進行數值運算，Pandas 會自動保留對應的索引。例如，s + 2 會讓每個數據值都加上 2。\ns + 2 每個數據加 2\ns.median() 計算中位數\ns.max() 找到最大值\nDataFrame DataFrame 是 Pandas 中的二維度數據結構，類似於完整的試算表資料，有欄和列。\n與 Series 不同，DataFrame 可以有多個列，每一列都可以有不同的數據類型。DataFrame 是由行和列組成的，每個行和列都有自己的標籤。\npd.DataFrame(字典) ，以字典的資料為底，建立dataframe\n1 2 3 4 5 6 7 8 import pandas as pd data = { \u0026#39;Name\u0026#39;: [\u0026#39;Anthony\u0026#39;, \u0026#39;Benedict\u0026#39;, \u0026#39;Collin\u0026#39;, \u0026#39;Daphne\u0026#39;], \u0026#39;Age\u0026#39;: [31,29,24,22], \u0026#39;Salary\u0026#39;: [75000,72000,60000,54000] } df = pd.DataFrame(data) print(df) Name Age Salary 0 Anthony 31 75000 1 Benedict 29 72000 2 Collin 24 60000 3 Daphne 22 54000 創建了一個 DataFrame，包含了三個欄位：Name，Age 和 Salary。每一列數據都可以有不同的類型，比如 Age 是整數，而 Name 是字串\n要選取 DataFrame 中的數據，我們可以使用列的名稱來選取特定的數據。\n舉個例子：\n我們用 df['Name'] 選取了 DataFrame 中的 Name 列\n這就像是提取 Excel 表中的某一列。你可以選取多列，使用 df[['Name', 'Salary']] 選取\n新增一列的方法很簡單，只需要指定列名，然後為每一行賦值\n新增列 1 2 df[\u0026#39;Bonus\u0026#39;] = [5000, 6000, 7000 ,8000] print(df) Name Age Salary Bonus 0 Anthony 31 75000 5000 1 Benedict 29 72000 6000 2 Collin 24 60000 7000 3 Daphne 22 54000 8000 新增行資料，使用 pd.concat() 1 2 3 4 5 6 7 8 9 10 # Pandas 1.4.0 版本之後，append() 方法已被棄用 new_row = pd.DataFrame({ \u0026#34;Name\u0026#34;: [\u0026#34;Ella\u0026#34;], \u0026#34;Age\u0026#34;: [25], \u0026#34;Salary\u0026#34;: [64500], \u0026#34;Bonus\u0026#34;: [1000] }) df = pd.concat([df, new_row], ignore_index=True) # pd.concat()：將原本的 DataFrame 與新增的資料行結合在一起。ignore_index=True 用於重新索引，使新行的索引從 0 開始連續排列。 print(df) Name Age Salary Bonus 0 Anthony 31 75000 5000 1 Benedict 29 72000 6000 2 Collin 24 60000 7000 3 Daphne 22 54000 8000 刪除列 1 2 df1 = df.drop (columns=[\u0026#39;Bonus\u0026#39;] ) print(df1) Name Age Salary 0 Anthony 31 75000 1 Benedict 29 72000 2 Collin 24 60000 3 Daphne 22 54000 4 Ella 25 64500 基本上不會刪除到原始資料，若要顯示出刪除後的結果，需要宣告新變數來存取執行結果\n資料集實戰練功 匯入實戰資料 出來吧 神奇寶貝! Pokemon DataSet\n匯入資料\npd.read_csv()：用來匯入 CSV 格式的資料 pd.read_excel()：用來匯入 Excel 格式的資料 1 2 import pandas as pd df = pd.read_csv(\u0026#34;檔案路徑\u0026#34;) 檢索資料 df.info()：顯示 DataFrame 的基本資訊，包括列數、欄數和每個欄位的數據類型，查看資料的資訊，包括欄位、數據型態、缺失值等 df.head()：取得最前面的n筆資料 df.tail()：取得最後面的n筆資料 df.column：列出欄位名稱 df.describe()：產生統計摘要，如平均值、最大值、標準差等。 df.shape：返回資料的行數與列數，了解資料的大小 1 df.info() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; RangeIndex: 800 entries, 0 to 799 Data columns (total 13 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 # 800 non-null int64 1 Name 800 non-null object 2 Type 1 800 non-null object 3 Type 2 414 non-null object 4 Total 800 non-null int64 5 HP 800 non-null int64 6 Attack 800 non-null int64 7 Defense 800 non-null int64 8 Sp. Atk 800 non-null int64 9 Sp. Def 800 non-null int64 10 Speed 800 non-null int64 11 Generation 800 non-null int64 12 Legendary 800 non-null bool dtypes: bool(1), int64(9), object(3) memory usage: 75.9+ KB 1 print(df.describe()) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Total HP Attack Defense Sp. Atk \\ count 800.000000 800.00000 800.000000 800.000000 800.000000 800.000000 mean 362.813750 435.10250 69.258750 79.001250 73.842500 72.820000 std 208.343798 119.96304 25.534669 32.457366 31.183501 32.722294 min 1.000000 180.00000 1.000000 5.000000 5.000000 10.000000 25% 184.750000 330.00000 50.000000 55.000000 50.000000 49.750000 50% 364.500000 450.00000 65.000000 75.000000 70.000000 65.000000 75% 539.250000 515.00000 80.000000 100.000000 90.000000 95.000000 max 721.000000 780.00000 255.000000 190.000000 230.000000 194.000000 Sp. Def Speed Generation count 800.000000 800.000000 800.00000 mean 71.902500 68.277500 3.32375 std 27.828916 29.060474 1.66129 min 20.000000 5.000000 1.00000 25% 50.000000 45.000000 2.00000 50% 70.000000 65.000000 3.00000 75% 90.000000 90.000000 5.00000 max 230.000000 180.000000 6.00000 1 2 #檢視欄位 print(df.columns) 1 2 3 Index([\u0026#39;#\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;Type 1\u0026#39;, \u0026#39;Type 2\u0026#39;, \u0026#39;Total\u0026#39;, \u0026#39;HP\u0026#39;, \u0026#39;Attack\u0026#39;, \u0026#39;Defense\u0026#39;, \u0026#39;Sp. Atk\u0026#39;, \u0026#39;Sp. Def\u0026#39;, \u0026#39;Speed\u0026#39;, \u0026#39;Generation\u0026#39;, \u0026#39;Legendary\u0026#39;], dtype=\u0026#39;object\u0026#39;) 1 2 #檢視前10筆資料 df.head(n=10) 檢視單個欄位資料 查看某個特定欄位（例如 Name 或 Type 1）的所有值\n1 2 # 查看 \u0026#39;Name\u0026#39; 欄位的所有資料 print(df[\u0026#39;Name\u0026#39;]) 1 2 3 4 5 6 7 8 9 10 11 12 0 Bulbasaur 1 Ivysaur 2 Venusaur 3 VenusaurMega Venusaur 4 Charmander ... 795 Diancie 796 DiancieMega Diancie 797 HoopaHoopa Confined 798 HoopaHoopa Unbound 799 Volcanion Name: Name, Length: 800, dtype: object 1 2 # 查看 \u0026#39;Type 1\u0026#39; 欄位的所有資料 print(df[\u0026#39;Type 1\u0026#39;]) 1 2 3 4 5 6 7 8 9 10 11 12 0 Grass 1 Grass 2 Grass 3 Grass 4 Fire ... 795 Rock 796 Rock 797 Psychic 798 Psychic 799 Fire Name: Type 1, Length: 800, dtype: object 檢視單個欄位資料 可以同時查看多個欄位，選取數個你感興趣的欄位作為子集\n1 2 # 查看多個欄位的資料 print(df[[\u0026#39;Name\u0026#39;, \u0026#39;HP\u0026#39;, \u0026#39;Attack\u0026#39;]]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name HP Attack 0 Bulbasaur 45 49 1 Ivysaur 60 62 2 Venusaur 80 82 3 VenusaurMega Venusaur 80 100 4 Charmander 39 52 .. ... .. ... 795 Diancie 50 100 796 DiancieMega Diancie 50 160 797 HoopaHoopa Confined 80 110 798 HoopaHoopa Unbound 80 160 799 Volcanion 80 110 [800 rows x 3 columns] 檢視單個欄位資料 可以透過行號來檢視某一特定行的所有資料\n1 2 # 查看第 15 行的所有資料 print(df.iloc[15]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 12 Name Butterfree Type 1 Bug Type 2 Flying Total 395 HP 60 Attack 45 Defense 50 Sp. Atk 90 Sp. Def 80 Speed 70 Generation 1 Legendary False Name: 15, dtype: object 1 2 # 查看指定範圍的行 print(df.iloc[0:5]) # 顯示第 0 到第 4 行 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense \\ 0 1 Bulbasaur Grass Poison 318 45 49 49 1 2 Ivysaur Grass Poison 405 60 62 63 2 3 Venusaur Grass Poison 525 80 82 83 3 3 VenusaurMega Venusaur Grass Poison 625 80 100 123 4 4 Charmander Fire NaN 309 39 52 43 Sp. Atk Sp. Def Speed Generation Legendary 0 65 65 45 1 False 1 80 80 60 1 False 2 100 100 80 1 False 3 122 120 80 1 False 4 60 50 65 1 False 根據條件篩選資料（查看子集） 可以根據某個欄位的值來篩選符合條件的行，例如查看所有屬性為 \u0026ldquo;Legendary\u0026rdquo; 的 Pokémon\n1 2 df[df[\u0026#39;Legendary\u0026#39;]==True].head(15) #Showing the legendary pokemons 查看特定欄位的統計資訊 除了 df.describe()，也可以對單個欄位執行統計操作，如查看 Attack 欄位的平均值、最大值等\n1 2 3 4 5 # 計算 \u0026#39;Attack\u0026#39; 欄位的平均值 print(df[\u0026#39;Attack\u0026#39;].mean()) # 查看 \u0026#39;Defense\u0026#39; 欄位的最大值 print(df[\u0026#39;Defense\u0026#39;].max()) 79.00125\n230\n檢視唯一值 查看某個欄位中有哪些唯一值，這對於分類資料（如 Type 2）很有幫助\n可以使用 unique() 來查看唯一值：\n1 2 3 4 # 查看 \u0026#39;Type 2\u0026#39; 欄位的所有唯一值 type2_unique = df[\u0026#39;Type 2\u0026#39;].unique() print(type2_unique) [\u0026lsquo;Poison\u0026rsquo; nan \u0026lsquo;Flying\u0026rsquo; \u0026lsquo;Dragon\u0026rsquo; \u0026lsquo;Ground\u0026rsquo; \u0026lsquo;Fairy\u0026rsquo; \u0026lsquo;Grass\u0026rsquo; \u0026lsquo;Fighting\u0026rsquo; \u0026lsquo;Psychic\u0026rsquo; \u0026lsquo;Steel\u0026rsquo; \u0026lsquo;Ice\u0026rsquo; \u0026lsquo;Rock\u0026rsquo; \u0026lsquo;Dark\u0026rsquo; \u0026lsquo;Water\u0026rsquo; \u0026lsquo;Electric\u0026rsquo; \u0026lsquo;Fire\u0026rsquo; \u0026lsquo;Ghost\u0026rsquo; \u0026lsquo;Bug\u0026rsquo; \u0026lsquo;Normal\u0026rsquo;]\n計算每個分類的出現頻率 可以計算每個分類在資料集中出現的次數，比如我們想知道 ‘Type 1’ 每個分類的出現頻率：\n1 2 3 4 # 計算 \u0026#39;Type 1\u0026#39; 每個分類的出現次數 type1_counts = df[\u0026#39;Type 1\u0026#39;].value_counts() print(type1_counts) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type1_counts = df[\u0026#39;Type 1\u0026#39;].value_counts() print(type1_counts) Type 1 Water 112 Normal 98 Grass 70 Bug 69 Psychic 57 Fire 52 Electric 44 Rock 44 Dragon 32 Ground 32 Ghost 32 Dark 31 Poison 28 Steel 27 Fighting 27 Ice 24 Fairy 17 Flying 4 Name: count, dtype: int64 檢視資料摘要（groupby） 想查看特定分類的統計摘要，可以使用 groupby() 來進行分組總結\n1 2 3 4 # 按 \u0026#39;Type 1\u0026#39; 分組，並查看每個屬性的平均攻擊力 grouped_data = df.groupby(\u0026#39;Type 1\u0026#39;)[\u0026#39;Attack\u0026#39;].mean() print(grouped_data) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Type 1 Bug 70.971014 Dark 88.387097 Dragon 112.125000 Electric 69.090909 Fairy 61.529412 Fighting 96.777778 Fire 84.769231 Flying 78.750000 Ghost 73.781250 Grass 73.214286 Ground 95.750000 Ice 72.750000 Normal 73.469388 Poison 74.678571 Psychic 71.456140 Rock 92.863636 Steel 92.703704 Water 74.151786 Name: Attack, dtype: float64 清理資料（Cleaning DataFrame） 在資料分析過程中，常常需要處理缺失值或重複資料。以下是幾個常用的清理資料的方法：\ndf.isnull().sum()：檢查資料集中每個欄位有多少缺失值，幫助找出需要清理的部分 df.dropna()：刪除包含缺失值的行，適用於缺失數據較少的情況 df.fillna(0)：將缺失值以指定的數值（如 0）填充，適用於缺失值較多且無法刪除的情況 df.duplicated().sum()：檢查是否有重複的資料行，避免數據重複影響分析結果 df.drop_duplicates()：刪除所有重複行，保留唯一的數據 1 2 # 檢查是否有缺失值 print(df.isnull().sum()) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 0 Name 0 Type 1 0 Type 2 386 Total 0 HP 0 Attack 0 Defense 0 Sp. Atk 0 Sp. Def 0 Speed 0 Generation 0 Legendary 0 dtype: int64 刪除包含缺失值的行 如果缺失的資料很關鍵且無法推測，可以直接刪除這些包含缺失值的行\n1 2 3 4 5 # 刪除包含缺失值的行 # 這樣會刪除 Type 2 欄位中缺失值的行，並留下屬性完整的資料 df_cleaned = df.dropna(subset=[\u0026#39;Type 2\u0026#39;]) print(df_cleaned.info()) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; Index: 414 entries, 0 to 799 Data columns (total 13 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 # 414 non-null int64 1 Name 414 non-null object 2 Type 1 414 non-null object 3 Type 2 414 non-null object 4 Total 414 non-null int64 5 HP 414 non-null int64 6 Attack 414 non-null int64 7 Defense 414 non-null int64 8 Sp. Atk 414 non-null int64 9 Sp. Def 414 non-null int64 10 Speed 414 non-null int64 11 Generation 414 non-null int64 12 Legendary 414 non-null bool dtypes: bool(1), int64(9), object(3) memory usage: 42.5+ KB None 用特定值填充缺失值 若想保留所有的資料，可以用一個合適的值來填充缺失的部分。\n例如，填充為 \u0026lsquo;None\u0026rsquo; 表示這些 Pokémon 沒有第二屬性\n1 2 3 4 5 # 使用 \u0026#39;None\u0026#39; 填充缺失的 Type 2 資料 # 可以保留所有的行，並以 \u0026#39;None\u0026#39; 來表示無第二屬性的 Pokémon df_filled = df.fillna({\u0026#39;Type 2\u0026#39;: \u0026#39;None\u0026#39;}) print(df_filled.head()) 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense \\ 0 1 Bulbasaur Grass Poison 318 45 49 49 1 2 Ivysaur Grass Poison 405 60 62 63 2 3 Venusaur Grass Poison 525 80 82 83 3 3 VenusaurMega Venusaur Grass Poison 625 80 100 123 4 4 Charmander Fire None 309 39 52 43 Sp. Atk Sp. Def Speed Generation Legendary 0 65 65 45 1 False 1 80 80 60 1 False 2 100 100 80 1 False 3 122 120 80 1 False 4 60 50 65 1 False 使用最常見的值進行填充 如果認為缺失值應該是某個常見的屬性，也可以用該屬性的名稱來填充。例如，填充為最常見的 Type 2 值。\n1 2 3 4 # 使用 \u0026#39;Type 2\u0026#39; 欄位的最常見值進行填充 most_common_type2 = df[\u0026#39;Type 2\u0026#39;].mode()[0] df_filled = df.fillna({\u0026#39;Type 2\u0026#39;: most_common_type2}) print(df_filled.head()) 保留缺失值並進行標記 如果希望保留缺失值，同時也想標記出哪些行有缺失的 Type 2，可以新增一個標記欄位。\n1 2 df[\u0026#39;Type 2 Missing\u0026#39;] = df[\u0026#39;Type 2\u0026#39;].isnull() print(df[[\u0026#39;Name\u0026#39;, \u0026#39;Type 2\u0026#39;, \u0026#39;Type 2 Missing\u0026#39;]].head()) 1 2 3 4 5 6 Name Type 2 Type 2 Missing 0 Bulbasaur Poison False 1 Ivysaur Poison False 2 Venusaur Poison False 3 VenusaurMega Venusaur Poison False 4 Charmander NaN True 檢查重複值 - df.duplicated().sum() 1 2 num_duplicates = df.duplicated().sum() print(f\u0026#34;重複行數：{num_duplicates}\u0026#34;) 重複行數：0\n篩選資料（Filtering DataFrame） 篩選資料是指從一個大的資料集中挑出我們關心的部分，可能是基於特定條件，像是某個欄位的值大於或小於某個數值。這在資料分析中非常重要，因為通常我們只對某些特定條件下的資料感興趣。\n單一條件篩選：df[df[\u0026lsquo;欄位\u0026rsquo;] \u0026gt; 某值] 多重條件篩選：df[(df[\u0026lsquo;欄位1\u0026rsquo;] \u0026gt; 某值) \u0026amp; (df[\u0026lsquo;欄位2\u0026rsquo;] \u0026lt; 某值)] 文字篩選：df[df[\u0026lsquo;欄位\u0026rsquo;] == \u0026lsquo;某文字\u0026rsquo;] 或使用 isin()、str.contains() 篩選區間：df[df[\u0026lsquo;欄位\u0026rsquo;].between(開始值, 結束值)] 篩選缺失值：df[df[\u0026lsquo;欄位\u0026rsquo;].isnull()] 或 notnull() 篩選前 N%：使用 quantile() 來篩選資料的百分比 根據單一條件篩選 可以根據條件，像這個例子中，我們篩選出 HP 值大於 100 的 Pokémon。\n1 2 3 # 篩選出 HP 大於 100 的 Pokémon high_hp_pokemon = df[df[\u0026#39;HP\u0026#39;] \u0026gt; 100] print(high_hp_pokemon.head()) 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense Sp. Atk \\ 44 39 Jigglypuff Normal Fairy 270 115 45 20 45 45 40 Wigglytuff Normal Fairy 435 140 70 45 85 96 89 Muk Poison NaN 500 105 105 75 65 120 112 Rhydon Ground Rock 485 105 130 120 45 121 113 Chansey Normal NaN 450 250 5 5 35 Sp. Def Speed Generation Legendary Type 2 Missing 44 25 20 1 False False 45 50 45 1 False False 96 100 50 1 False True 120 45 40 1 False False 121 105 50 1 False True 根據多重條件篩選 1 2 3 # 篩選出 HP 大於 100 且 Attack 超過 80 的 Pokémon strong_pokemon = df[(df[\u0026#39;HP\u0026#39;] \u0026gt; 100) \u0026amp; (df[\u0026#39;Attack\u0026#39;] \u0026gt; 80)] print(strong_pokemon.head()) 這裡用到的 \u0026amp; 是 “且” 的意思，代表我們要同時滿足兩個條件，兩個條件必須同時成立：HP \u0026gt; 100 且 Attack \u0026gt; 80。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack \\ 96 89 Muk Poison NaN 500 105 105 120 112 Rhydon Ground Rock 485 105 130 123 115 Kangaskhan Normal NaN 490 105 95 124 115 KangaskhanMega Kangaskhan Normal NaN 590 105 125 142 131 Lapras Water Ice 535 130 85 Defense Sp. Atk Sp. Def Speed Generation Legendary Type 2 Missing 96 75 65 100 50 1 False True 120 120 45 45 40 1 False False 123 80 40 80 90 1 False True 124 100 60 100 100 1 False True 142 80 85 95 60 1 False False 根據文字內容篩選 有時我們想根據文字內容篩選，例如這裡的例子，我們要篩選出 Type 1 為 ‘Fire’ 的 Pokémon。這時我們可以直接使用條件篩選來進行\n1 2 fire_pokemon = df[df[\u0026#39;Type 1\u0026#39;] == \u0026#39;Fire\u0026#39;] print(fire_pokemon.head()) 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense \\ 4 4 Charmander Fire NaN 309 39 52 43 5 5 Charmeleon Fire NaN 405 58 64 58 6 6 Charizard Fire Flying 534 78 84 78 7 6 CharizardMega Charizard X Fire Dragon 634 78 130 111 8 6 CharizardMega Charizard Y Fire Flying 634 78 104 78 Sp. Atk Sp. Def Speed Generation Legendary Type 2 Missing 4 60 50 65 1 False True 5 80 65 80 1 False True 6 109 85 100 1 False False 7 130 85 100 1 False False 8 159 115 100 1 False False 多個欄位的條件篩選 有時候我們需要同時根據多個欄位進行篩選，這些欄位的條件可能不相同。比如我們想篩選出 Type 1 為 ‘Water’ 且 Speed 大於 80 的 Pokémon：\n1 2 fast_water_pokemon = df[(df[\u0026#39;Type 1\u0026#39;] == \u0026#39;Water\u0026#39;) \u0026amp; (df[\u0026#39;Speed\u0026#39;] \u0026gt; 80)] print(fast_water_pokemon.head()) 這裡我們用到了兩個條件：一個是 Type 1 為 ‘Water’，另一個是 Speed 大於 80，並且我們用 \u0026amp; 將兩個條件連接在一起，表示這兩個條件都必須滿足。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense Sp. Atk \\ 60 55 Golduck Water NaN 500 80 82 78 95 65 60 Poliwag Water NaN 300 40 50 40 40 66 61 Poliwhirl Water NaN 385 65 65 65 50 79 73 Tentacruel Water Poison 515 80 70 65 80 126 117 Seadra Water NaN 440 55 65 95 95 Sp. Def Speed Generation Legendary Type 2 Missing 60 80 85 1 False True 65 40 90 1 False True 66 50 90 1 False True 79 120 100 1 False False 126 45 85 1 False True 篩選特定區間的數值 除了篩選固定的數值外，我們還可以篩選區間內的資料。這裡，我們篩選 Attack 值在 50 到 100 之間的 Pokémon：\n1 2 mid_attack_pokemon = df[df[\u0026#39;Attack\u0026#39;].between(50, 100)] print(mid_attack_pokemon.head()) .between(50, 100) 是一個很方便的函數，它會幫助我們篩選出 Attack 在 50 到 100 之間的資料。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense \\ 1 2 Ivysaur Grass Poison 405 60 62 63 2 3 Venusaur Grass Poison 525 80 82 83 3 3 VenusaurMega Venusaur Grass Poison 625 80 100 123 4 4 Charmander Fire NaN 309 39 52 43 5 5 Charmeleon Fire NaN 405 58 64 58 Sp. Atk Sp. Def Speed Generation Legendary Type 2 Missing 1 80 80 60 1 False False 2 100 100 80 1 False False 3 122 120 80 1 False False 4 60 50 65 1 False True 5 80 65 80 1 False True 篩選出缺失值的資料 在真實世界的資料中，經常會遇到缺失值。這時我們可能需要篩選出包含缺失值的資料，像這裡篩選出 Type 2 欄位缺失的 Pokémon：\n1 2 missing_type2_pokemon = df[df[\u0026#39;Type 2\u0026#39;].isnull()] print(missing_type2_pokemon.head()) .isnull() 函數會返回一個布林值，True 表示該欄位的值為缺失值，因此我們篩選出來的是 Type 2 欄位為空的資料。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense Sp. Atk Sp. Def \\ 4 4 Charmander Fire NaN 309 39 52 43 60 50 5 5 Charmeleon Fire NaN 405 58 64 58 80 65 9 7 Squirtle Water NaN 314 44 48 65 50 64 10 8 Wartortle Water NaN 405 59 63 80 65 80 11 9 Blastoise Water NaN 530 79 83 100 85 105 Speed Generation Legendary Type 2 Missing 4 65 1 False True 5 80 1 False True 9 43 1 False True 10 58 1 False True 11 78 1 False True 根據多個選項篩選 可以使用 isin() 函數來篩選出符合多個選項的資料。例如，篩選出屬性為 \u0026ldquo;Fire\u0026rdquo; 或 \u0026ldquo;Water\u0026rdquo; 的 Pokémon\n1 2 fire_water_pokemon = df[df[\u0026#39;Type 1\u0026#39;].isin([\u0026#39;Fire\u0026#39;, \u0026#39;Water\u0026#39;])] print(fire_water_pokemon.head()) isin() 函數可以幫助我們在多個選項中進行篩選。這個例子篩選出的是 Type 1 屬於 ‘Fire’ 或 ‘Water’ 的資料。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense \\ 4 4 Charmander Fire NaN 309 39 52 43 5 5 Charmeleon Fire NaN 405 58 64 58 6 6 Charizard Fire Flying 534 78 84 78 7 6 CharizardMega Charizard X Fire Dragon 634 78 130 111 8 6 CharizardMega Charizard Y Fire Flying 634 78 104 78 Sp. Atk Sp. Def Speed Generation Legendary Type 2 Missing 4 60 50 65 1 False True 5 80 65 80 1 False True 6 109 85 100 1 False False 7 130 85 100 1 False False 8 159 115 100 1 False False 根據字串條件篩選 有時我們可能需要篩選包含某個字串的資料。例如篩選出名字中包含 ‘Mega’ 的 Pokémon：\n1 2 mega_pokemon = df[df[\u0026#39;Name\u0026#39;].str.contains(\u0026#39;Mega\u0026#39;)] print(mega_pokemon.head()) 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense \\ 3 3 VenusaurMega Venusaur Grass Poison 625 80 100 123 7 6 CharizardMega Charizard X Fire Dragon 634 78 130 111 8 6 CharizardMega Charizard Y Fire Flying 634 78 104 78 12 9 BlastoiseMega Blastoise Water NaN 630 79 103 120 19 15 BeedrillMega Beedrill Bug Poison 495 65 150 40 Sp. Atk Sp. Def Speed Generation Legendary Type 2 Missing 3 122 120 80 1 False False 7 130 85 100 1 False False 8 159 115 100 1 False False 12 135 115 78 1 False True 19 15 80 145 1 False False 篩選出資料的前 N% 有時可能需要篩選出資料集中數值最高或最低的前幾個百分比。例如，篩選出攻擊力最高的前 10% Pokémon\n1 2 top_10_percent_attack = df[df[\u0026#39;Attack\u0026#39;] \u0026gt; df[\u0026#39;Attack\u0026#39;].quantile(0.9)] print(top_10_percent_attack.head()) quantile() 是 用來計算指定百分比位置數值的函數。這個函數的功能是告訴你一組數據中，在某個百分比對應的數值是多少。比如當你設定 0.9，這表示你想知道數據集中位於前 90% 的臨界值是多少。\n簡單來說，quantile(0.9) 就是幫你找到數據中排在前 90% 位置的值。\ndf[\u0026lsquo;Attack\u0026rsquo;].quantile(0.9)：計算 Attack 欄位中，位於前 90% 的臨界值。例如，如果 Attack 最大是 150，最小是 20，這個函數可能會告訴我們前 90% 對應的攻擊值是 120。也就是說，攻擊力在 120 以上的寶可夢屬於前 10%。 df[\u0026lsquo;Attack\u0026rsquo;] \u0026gt; df[\u0026lsquo;Attack\u0026rsquo;].quantile(0.9)：找出那些攻擊力大於剛才計算出來的 90% 臨界值的寶可夢。它會產生一個布林值的 Series，顯示哪一筆資料符合這個條件。 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack \\ 7 6 CharizardMega Charizard X Fire Dragon 634 78 130 19 15 BeedrillMega Beedrill Bug Poison 495 65 150 74 68 Machamp Fighting NaN 505 90 130 107 99 Kingler Water NaN 475 55 130 120 112 Rhydon Ground Rock 485 105 130 Defense Sp. Atk Sp. Def Speed Generation Legendary Type 2 Missing 7 111 130 85 100 1 False False 19 40 15 80 145 1 False False 74 80 65 85 55 1 False True 107 115 50 50 75 1 False True 120 120 45 45 40 1 False False 排序資料（Sorting DataFrame） df.sort_values(\u0026lsquo;欄位\u0026rsquo;)：根據指定的欄位進行排序，默認為升序排列。 *ascending=True：指定排序方向為升序。若要降序，將 ascending 設為 False 根據單一欄位排序 1 2 3 # 根據 Attack 欄位進行升序排序 df_sorted_attack = df.sort_values(\u0026#39;Attack\u0026#39;, ascending=True) print(df_sorted_attack.head()) 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense Sp. Atk \\ 488 440 Happiny Normal NaN 220 100 5 5 15 121 113 Chansey Normal NaN 450 250 5 5 35 230 213 Shuckle Bug Rock 505 20 10 230 10 261 242 Blissey Normal NaN 540 255 10 10 75 139 129 Magikarp Water NaN 200 20 10 55 15 Sp. Def Speed Generation Legendary Type 2 Missing 488 65 30 4 False True 121 105 50 1 False True 230 230 5 2 False False 261 135 55 2 False True 139 20 80 1 False True 根據多個欄位進行排序 不僅可以根據單一欄位排序，也可以根據多個欄位進行排序。這在分析時是非常有用的。\n例如，先根據 Pokémon 的攻擊力（Attack）進行升序排序，若攻擊力相同，再根據防禦力（Defense）進行降序排序。\n1 2 3 # 根據 Attack 升序，Defense 降序進行排序 df_sorted_multi = df.sort_values([\u0026#39;Attack\u0026#39;, \u0026#39;Defense\u0026#39;], ascending=[True, False]) print(df_sorted_multi.head()) 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense Sp. Atk \\ 121 113 Chansey Normal NaN 450 250 5 5 35 488 440 Happiny Normal NaN 220 100 5 5 15 230 213 Shuckle Bug Rock 505 20 10 230 10 139 129 Magikarp Water NaN 200 20 10 55 15 261 242 Blissey Normal NaN 540 255 10 10 75 Sp. Def Speed Generation Legendary Type 2 Missing 121 105 50 1 False True 488 65 30 4 False True 230 230 5 2 False False 139 20 80 1 False True 261 135 55 2 False True 根據索引排序 可以根據 DataFrame 的索引（行標籤）進行排序。這有助於根據行索引進行重整或檢查資料順序\n1 2 3 4 5 6 7 # 根據索引進行升序排序 df_sorted_index = df.sort_index() print(df_sorted_index.head()) # 根據索引降序排序 df_sorted_index_desc = df.sort_index(ascending=False) print(df_sorted_index_desc.head()) 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense \\ 0 1 Bulbasaur Grass Poison 318 45 49 49 1 2 Ivysaur Grass Poison 405 60 62 63 2 3 Venusaur Grass Poison 525 80 82 83 3 3 VenusaurMega Venusaur Grass Poison 625 80 100 123 4 4 Charmander Fire NaN 309 39 52 43 Sp. Atk Sp. Def Speed Generation Legendary Type 2 Missing 0 65 65 45 1 False False 1 80 80 60 1 False False 2 100 100 80 1 False False 3 122 120 80 1 False False 4 60 50 65 1 False True 1 2 3 4 5 6 7 8 9 10 11 12 13 # Name Type 1 Type 2 Total HP Attack Defense \\ 799 721 Volcanion Fire Water 600 80 110 120 798 720 HoopaHoopa Unbound Psychic Dark 680 80 160 60 797 720 HoopaHoopa Confined Psychic Ghost 600 80 110 60 796 719 DiancieMega Diancie Rock Fairy 700 50 160 110 795 719 Diancie Rock Fairy 600 50 100 150 Sp. Atk Sp. Def Speed Generation Legendary Type 2 Missing 799 130 90 70 6 True False 798 170 130 80 6 True False 797 150 130 70 6 True False 796 160 110 110 6 True False 795 100 150 50 6 True False sort_index() 和 sort_values() 的比較 sort_index() 是用來針對DataFrame 的索引進行排序，這在需要按照行或列的索引順序（如按時間、ID 等）進行排序時非常有用。它不關注欄位的具體數值，而是針對 DataFrame 的結構順序進行操作。 sort_values() 是用來根據指定的欄位內容進行排序，當你需要根據某個數據欄位（如攻擊力、價格等）來排序資料時，這個函數就很有用。 輸出資料 可以使用 DataFrame.to_csv(\u0026lsquo;檔案名稱\u0026rsquo;)、DataFrame.to_json(\u0026lsquo;檔案名稱\u0026rsquo;)、DataFrame.to_excel(\u0026lsquo;檔案名稱) 和 DataFrame.to_html(\u0026lsquo;檔案名稱\u0026rsquo;) 將資料轉成檔案\n參數說明：\nsep：設定欄位的分隔符，預設為逗號（,）。 index：是否寫入索引列，預設為 True。可以設定為 False，以避免寫入行索引。 header：是否寫入列名稱，預設為 True。可以設定為 False，以避免寫入列名稱。 encoding：設定檔案編碼格式，預設為 utf-8。可以根據需求調整編碼格式。 mode：寫入模式。預設為 \u0026lsquo;w\u0026rsquo;（覆蓋寫入）。可以設定為 \u0026lsquo;a\u0026rsquo; 以追加模式寫入檔案。 decimal：設定浮點數的小數點分隔符，預設為 .。 CSV 格式輸出 1 2 # 基本用法 df.to_csv(\u0026#39;file_name.csv\u0026#39;) 1 2 # 不寫入索引、沒有標題行，並用 UTF-16 編碼保存 df.to_csv(\u0026#39;file_name.csv\u0026#39;, index=False, header=False, encoding=\u0026#39;utf-16\u0026#39;) Excel 格式輸出 1 2 # 基本用法 df.to_excel(\u0026#39;file_name.xlsx\u0026#39;) 1 2 # 輸出到 Excel 並指定工作表名稱 df.to_excel(\u0026#39;file_name.xlsx\u0026#39;, sheet_name=\u0026#39;Sheet1\u0026#39;, index=False) I hope this will help u know more about Pandas, And check out the Pandas AI at next article ~ Byeeee\n","date":"2024-10-25T00:00:00Z","image":"https://KathyKo.github.io/p/pandas-basic/Pandas_hu2443763577485353119.png","permalink":"https://KathyKo.github.io/p/pandas-basic/","title":"Pandas Basic For Data Analysis"},{"content":"WHAT IS PYTHON Python是非常受歡迎的程式語言，因為容易閱讀和理解，且擁有龐大的開發者社群提供各種函式庫、框架以及教學課程，相對容易學習上手，適合新手入門學習的程式語言。\n程式碼的可讀性高，語法接近英文，相較其它的程式語言，例如：C++或Java，Python 指令撰寫較簡潔，可以用更少的程式碼即能達到同樣的結果\n(當然Java, C都有其存在的必要性)\n同時Python應用範圍非常廣泛，也是市場上工作機會需求最大的程式語言之一。 Python 自學資源 Python 官方文檔 ‍Learn Python：給非技術背景初學者入門的網站 DataCamp：側重於數據科學的Python教學 FreeCodecamp：4小時的英文初學者教程，有中文字幕 Google：Google’s Python Class IBM：Python for Data Science, AI \u0026amp; Development Youtube影片 有了AI，為何還要學python? 在資料分析的過程中，的確有很多工具可以幫助我們進行數據處理、分析和視覺化， 甚至透過AI，可以不需要寫程式，只靠指令就能達到目的。\nPython作為資料分析領域中最常用的程式語言之一，今天不僅僅是學一個工具，學習過程一種 「思考和解決問題的方式」。 當你用 Python 進行資料分析時，實際上是在鍛煉自己的邏輯思維和問題拆解能力。AI 可能能幫你建立模型，但只有人能找出為什麼模型結果不如預期，或者數據處理出現錯誤的根本原因。\n我們需要的不是更多的工具，而是對數據和邏輯的深入理解，並有能力去拆解問題、排查錯誤，找到解決辦法。 Python 幫助你透過程式碼來一步一步進行分析、偵錯，這是一個 AI 無法完全取代的過程。\n我會認為學習不論是Python或是其他的工具， 並不是為了讓你比 AI 工具更強，而是為了讓你能在面對錯誤、困境時，有能力拆解問題，還有切入問題的方式和工具，找到解決方案💪\n變數 程式語言中等號的意思是，將等號右邊的值傳給左邊的變數。 比方說，牛排=160，就是把 160 這個數字放進 牛排 這個箱子裡。\n當我們給變數賦值時，電腦會在記憶體裡找到一個位置來存放這個值，並且會將這個位置與變數名稱關聯起來。這樣當我們在程式中提到變數名稱的時候，電腦就能夠快速找到記憶體中的對應位置，然後取出我們存放的資料。\n命名首字需要用英文可搭配數字，基本上命變數還是建議用「 駝峰式命名 」，在程式碼閱讀上會較為方便，也可以將不同單字用下底線分開ex:DAC_Class，變數名稱不能出現_以外的符號 ** 駝峰式命名: 變數名稱由多個單詞組成，第一個單詞的首字母小寫，後面每個單詞的首字母都大寫，這樣名稱就像駱駝的駝峰一樣。e.g.:TotalScore\n變數命名規則： 在 Python 中，變數名稱有一些基本規則：\n變數名稱可以包含字母、數字和底線（_）。例如：age、student_name 變數名稱不能以數字開頭。例如：2name 是不合格的變數，但 name2 是合格的 變數名稱區分大小寫。例如：Age 和 age 是兩個不同的變數 避免使用 Python 的關鍵字作為變數名稱（例如：if、else、for 等） 基礎輸入與輸出 輸出：使用 print() 函數將訊息顯示在執行結果。\n語法：print(要輸出的內容)\n輸入：使用 input() 函數來讓使用者輸入資料。\n語法：變數 = input(提示文字)。\ninput() 函數會等待使用者輸入資料，並將其存儲在變數中。\n1 print(\u0026#34;Hello, World!\u0026#34;) Hello, World!\n1 2 name = input(\u0026#34;請輸入你的名字：\u0026#34;) print(\u0026#34;你好，\u0026#34; , name) 請輸入你的名字：abc\n你好，abc\n資料型態 資料型態大致可以分成三大類，分別是數值型態、字串型態和容器型態。\n數值型態：int, float, bool 字串型態：str, chr 容器型態：list, dict, tuple, set 數值資料型態 （Number） 整數（int）：沒有小數點的數字，例如：1、100、-50。 浮點數（float）：帶有小數點的數字，例如：3.14、-0.001。 布林值(boolean) : 決定邏輯判斷，True 或 False 1 2 3 4 # int 整數 x = 1 print(x) print(type(x)) 1\n\u0026lt;class \u0026lsquo;int\u0026rsquo;\u0026gt;\n1 2 3 4 5 # int 整數 # float 浮點數 y = 1.5 print(y) print(type(y)) 1.5\n\u0026lt;class \u0026lsquo;float\u0026rsquo;\u0026gt;\n1 2 3 4 # bool 布林值 True False a = True print(a) print(type(a)) True \u0026lt;class \u0026lsquo;bool\u0026rsquo;\u0026gt;\n1 2 3 4 # 布林值通常是一個運算的結果 a = 1 b = 1 print(a==b) True\n其中 a==b 是一個運算結果，會回傳 a 是否等於 b。 因為 a 的值是 1、b的值是 2，所以 a 不會等於 b。 a==b 這個布林值的值就會是 False 。\n字串/字元資料型態 String/Character Data Types 1. 字串 string (str) 字串資料是以單引號 (\u0026rsquo;)或雙引號(\u0026quot;)所包起來的文字資料，由一連串字元所組成。 使用單引號或是雙引號的時機沒有一定， 若是字串中本身就包含單引號或是雙引號，就可以使用另一種引號以利區別。\n1 2 3 4 # 布林值通常是一個運算的結果 song = \u0026#39;Just the way you are\u0026#39; print(song) print(type(song)) Just the way you are\n\u0026lt;class \u0026lsquo;str\u0026rsquo;\u0026gt;\n1 print(\u0026#34; \u0026#34;Espresso\u0026#34; is a song by Sabrina Carpenter.\u0026#34;) SyntaxError: invalid syntax\n其中把“Espresso”這首歌括號起來，會使 Python 認為要印出的字串為 “ “(空字串)、以及” is a song by Sabrina Carpenter.”，因而出現error。\n1 print(\u0026#39;\u0026#34;Espresso\u0026#34; is a song by Sabrina Carpenter.\u0026#39;) \u0026ldquo;Espresso\u0026rdquo; is a song by Sabrina Carpenter.\n字串的處理 (1) 字串相加\n1 2 3 str1 = \u0026#34;Girl, you\u0026#39;re amazing.\u0026#34; str2 = \u0026#34;Just the way you are\u0026#34; print(str1 + str2) Girl, you\u0026rsquo;re amazing.Just the way you are\n(2) 重複印出字串\n輸入字串與 * 再加上想要重複印出的字串即可\n1 2 str = \u0026#34;Hello\u0026#34; print(str*5) (3) 計算字串長度\n利用 len() 這個函式會回傳字串的長度\n1 2 3 str = \u0026#34;asdfghjklzxcvbnmqwertyuiop\u0026#34; print(str) print(len(str)) (4) 取得字串中的某個字符\n1 2 3 word = \u0026#34;Python\u0026#34; print(word[0]) # 第一個字元 print(word[-1]) # 最後一個字元 P\nH\n2. 字元 character (chr) 字元就是組成字串的元素。 例如在字串 Python 中，\n\u0026lsquo;p\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, \u0026rsquo;t\u0026rsquo;, \u0026lsquo;h\u0026rsquo;, \u0026lsquo;o\u0026rsquo;, \u0026rsquo;n\u0026rsquo; 每個字母都是一個字元。\n型態轉換 1 2 3 4 5 # 整數轉換成浮點數 num_int = 209 num_float = float(num_int) print(num_float) print(type(num_float)) 209.0\n\u0026lt;class \u0026lsquo;float\u0026rsquo;\u0026gt;\n1 2 3 4 # 浮點數轉換成整數（會捨棄小數部分） num_float = 3.1415926 num_int = int(num_float) print(num_int) 3\n1 2 3 4 5 # 字串轉換成整數或浮點數 string_1 = \u0026#34;103\u0026#34; num_int = int(string_1) num_float = float(string_1) print(num_int) 103\n1 2 3 4 # 布林值轉換成整數（True 為 1，False 為 0） bool_value = False num_int = int(bool_value) print(num_int) 0\nPrint的參數格式化 在 Python 中，我們有時需要更靈活地控制輸出的內容，讓數字、字串等資料顯示得更符合我們的需求。\n這時候可以使用 % 進行字串格式化，這種方法就像填空題一樣，把變數的值放進我們設定的格式裡面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # %%：顯示「%」 percentage = \u0026#34;顯示百分比符號：%%\u0026#34; % () print(percentage) # %d：整數輸出 age = 25 print(\u0026#34;我今年 %d 歲。\u0026#34; % age) # %f：浮點數輸出 pi = 3.14159 print(\u0026#34;圓周率的近似值是：%f\u0026#34; % pi) # %s：字串輸出 name = \u0026#34;Alice\u0026#34; print(\u0026#34;你好，%s！\u0026#34; % name) # %e：科學記號法輸出 large_number = 123456789 print(\u0026#34;科學記號法表示：%e\u0026#34; % large_number) 顯示百分比符號：%\n我今年 25 歲。\n圓周率的近似值是：3.141590\n你好，Alice！\n科學記號法表示：1.234568e+08\n容器型態(Container Datatypes) Python 的容器型態，也就是能夠用來存放多個資料的結構。\n這些結構讓我們可以更方便地組織和管理大量的數據。\n主要有四種常見容器型態：\nList(串列) Tuple(元組) Set(集合) Dictionary(字典) List(列表) 列表可以儲存很多不同的東西，像是數字、字串，甚至是其他列表。\n它的特點是有順序，也就是說，可以依據編號（索引）來取出列表中每個元素。\n索引從 0 開始，意味著列表的第一個元素索引是 0，第二個是 1，以此類推。\nlist是一個值可變、可重複、存放有順序性的資料結構。使用 [ ] 表示 index從0開始。列表中的元素可以被修改、添加或刪除 1 2 3 4 5 6 # 布林值轉換成整數（True 為 1，False 為 0） student_name = [\u0026#34;Amy\u0026#34;, \u0026#34;Bill\u0026#34;, \u0026#34;Cony\u0026#34;] student_score = [100, 90, 80] print(student_name[2]) print(student_score[0]) Cony\n100\n新增/刪除/修改list的值 append：從List尾端新增一個元素 insert：在List的任何位置插入元素 remove: 將List中某個數值刪除 pop(): 將List尾端的元素刪除 del: 將List該位置的值刪除 建立一個List\n1 animals = [\u0026#34;bear\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;elephant\u0026#34;] 1 2 animals.append(\u0026#34;fox\u0026#34;) #新增一個元素\u0026#34;fox\u0026#34; print(animals) [\u0026lsquo;bear\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026lsquo;dog\u0026rsquo;, \u0026rsquo;elephant\u0026rsquo;, \u0026lsquo;fox\u0026rsquo;]\n1 2 animals.pop() #括號內不需放值，會自動刪除最後一個 print(animals) [\u0026lsquo;bear\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026lsquo;dog\u0026rsquo;, \u0026rsquo;elephant\u0026rsquo;]\n1 2 animals.insert(2,\u0026#34;panda\u0026#34;) #List的第二個元素在\u0026#34;cat\u0026#34;插入後變成\u0026#34;panda\u0026#34; print(animals) [\u0026lsquo;bear\u0026rsquo;, \u0026lsquo;panda\u0026rsquo;, \u0026lsquo;bird\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026lsquo;dog\u0026rsquo;, \u0026rsquo;elephant\u0026rsquo;]\n1 2 animals.remove(\u0026#34;dog\u0026#34;) # 刪除\u0026#34;dog\u0026#34; print(animals) [\u0026lsquo;bear\u0026rsquo;, \u0026lsquo;bird\u0026rsquo;, \u0026lsquo;bird\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026rsquo;elephant\u0026rsquo;]\n取得長度 使用 len(list)\n1 2 student = [\u0026#39;Amy\u0026#39;, \u0026#39;Bill\u0026#39;, \u0026#39;Cony\u0026#39;, \u0026#39;Dora\u0026#39;, \u0026#34;Ellie\u0026#34;] print(len(student)) 5\n常用位置函數 sort()：List排序 reverse()：反轉List的順序 index()：某值在List第一次出現的索引位置 count()：某值在List出現的次數 建立兩個list\n1 2 animals = [\u0026#39;bear\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;cat\u0026#39;] num = [21, 32, 43, 54, 65, 23, 34, 35] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #在sort中可以加入reverse參數調整升降(默認是升序) #reverse = True 降序， reverse = False 升序 #都沒打就是默認reverse = False animals.sort() #排序方法按照字母順序 num.sort() #數字會按照數字小到大 print(animals) print(num) animals.sort(reverse = True) #排序方法按照字母順序 num.sort(reverse = True) print(animals) print(num) [\u0026lsquo;bear\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026lsquo;dog\u0026rsquo;, \u0026rsquo;elephant\u0026rsquo;]\n[21, 23, 32, 34, 35, 43, 54, 65]\n[\u0026rsquo;elephant\u0026rsquo;, \u0026lsquo;dog\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026lsquo;bear\u0026rsquo;]\n[65, 54, 43, 35, 34, 32, 23, 21]\n1 2 animals = [\u0026#39;bear\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#34;Cat\u0026#34;] print(animals.count(\u0026#39;cat\u0026#39;)) #cat總共出現幾次 2\n其中cat和Cat為不同元素\nTuple (元組) Tuple是一個值不可變、可重複、存放有順序性的資料結構。使用 ( ) 表示 ⭢ 給定元素後不能改變\n1 2 3 animals = (\u0026#39;bear\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;cat\u0026#39;) print(animals) print(animals[1]) (\u0026lsquo;bear\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;, \u0026lsquo;dog\u0026rsquo;, \u0026rsquo;elephant\u0026rsquo;, \u0026lsquo;cat\u0026rsquo;)\ncat\n1 animals[0] = \u0026#34;peoele\u0026#34; TypeError: \u0026rsquo;tuple\u0026rsquo; object does not support item assignment 建立了一個名為 animals 的tuple，和list一樣可以用索引取值，但是不能像list一樣去改變內容。如果嘗試更改tuple的值，會報錯。\nSet (集合) Set和List最大的不同在於它沒有順序，也不允許有重複的元素。\n這就像是我們在統計數據時，希望去掉重複的部分，只保留獨一無二的資料。\nSet是一個值可變、不可重複、存放沒有順序性的資料結構。用大括號 { } 表示 值重複時，僅會保留一個 只有元素值(value)，沒有鍵值(key)。 1 2 set1 = {1, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 1} print(set1) {1, 2, 3, 4, 5, 6, 7, 8, 9}\n常用函數 add( )：新增資料 remove( )：刪除資料 len( )： 回傳長度 sum( )： 回傳總和 max( )： 回傳最大值 min( )： 回傳最小值 1 2 3 4 5 6 set2 = {1, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 1} #新增10, 刪除5 set2.add(100) set2.remove(5) print(set2) {1, 2, 3, 4, 6, 7, 8, 9, 100}\n1 2 3 4 5 6 set2 = {1, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 11, 11} print(\u0026#34;長度: %d \u0026#34; %len(set2)) #回傳長度 print(\u0026#34;總和: %d \u0026#34; %sum(set2)) #總和 print(\u0026#34;最大值: %d \u0026#34; %max(set2)) #最大值 print(\u0026#34;最小值: %d \u0026#34; %min(set2)) #最小值 長度: 10\n總和: 56\n最大值: 11\n最小值: 1\nDictionary (字典) Dictionary的特色是用 key 和 value 的方式來存儲資料，可以把它想像成一個電話簿，key 是名字，value 是對應的電話號碼。\nDictionary是一個值可變、可重複、存放使用唯一識別Key的資料結構。 以大括號{}存放元素，每個元素是由一對「鍵值(key):元素值(value)」組合而成。 {key1:value1, key2:value2} key是唯一值，如果有重複，後面的資料會覆蓋前面的資料 1 2 3 4 5 6 # 初始化字典 dict_1 = {\u0026#34;name\u0026#34;: \u0026#34;Gary\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;age\u0026#34;: 28} # 1. clear(): 清空字典 dict_1.clear() print(dict_1) { }\n1 2 3 4 5 dict = {\u0026#34;name\u0026#34;: \u0026#34;Gary\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;age\u0026#34;: 28} # 2. copy(): 複製字典 dict_copy = dict.copy() print(\u0026#34;複製的字典：\u0026#34;, dict_copy) 複製的字典： {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;Gary\u0026rsquo;, \u0026lsquo;gender\u0026rsquo;: \u0026lsquo;male\u0026rsquo;, \u0026lsquo;age\u0026rsquo;: 28}\n1 2 3 4 5 6 7 8 # 3. get(): 取得指定 key 的元素值 age = dict.get(\u0026#34;age\u0026#34;) print(\u0026#34;取得的 age 值：\u0026#34;, age) # 4. pop(): 移除指定 key 的元素值 removed_value = dict.pop(\u0026#34;gender\u0026#34;) print(\u0026#34;移除的值：\u0026#34;, removed_value) print(\u0026#34;移除後的字典：\u0026#34;, dict) 取得的 age 值： 28\n移除的值： male\n移除後的字典： {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;Gary\u0026rsquo;, \u0026lsquo;age\u0026rsquo;: 28}\n1 2 3 4 5 6 7 8 9 10 dict = {\u0026#34;name\u0026#34;: \u0026#34;Gary\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;age\u0026#34;: 28} # 5. update(): 合併字典 new_info = {\u0026#34;height\u0026#34;: 175, \u0026#34;age\u0026#34;: 29} # 新的字典，用來合併 dict.update(new_info) print(\u0026#34;合併後的字典：\u0026#34;, dict) # 6. len(): 回傳字典中的 key:value 組數 length = len(dict) print(\u0026#34;字典的長度：\u0026#34;, length) 合併後的字典： {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;Gary\u0026rsquo;, \u0026lsquo;gender\u0026rsquo;: \u0026lsquo;male\u0026rsquo;, \u0026lsquo;age\u0026rsquo;: 29, \u0026lsquo;height\u0026rsquo;: 175}\n字典的長度： 4\n綜合比較 資料型態綜合練習 假設你正在設計一個系統來儲存顧客的基本資訊，請依據以下步驟完成：\n創建一個名為 customer 的字典，使用者會輸入姓名、性別和年齡，並將這些資訊存入一個字典中。\n請使用 input() 函數，讓使用者輸入顧客的城市（city），並將其存入字典中。 請輸出顧客的所有資訊（使用 print() 輸出整個字典）。 該字典目前包含多少組 key:value。 假設顧客搬家了，將顧客的城市更新為新的城市 \u0026ldquo;Taipei\u0026rdquo;。 移除顧客的性別資訊，並顯示移除後的字典內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 1. 創建一個名為 customer 的字典，並讓使用者輸入姓名、性別和年齡 customer = {} customer[\u0026#34;name\u0026#34;] = input(\u0026#34;請輸入顧客的姓名：\u0026#34;) customer[\u0026#34;gender\u0026#34;] = input(\u0026#34;請輸入顧客的性別：\u0026#34;) customer[\u0026#34;age\u0026#34;] = int(input(\u0026#34;請輸入顧客的年齡：\u0026#34;)) # 2. 請使用 input() 函數，讓使用者輸入顧客的城市，並將其存入字典中 customer[\u0026#34;city\u0026#34;] = input(\u0026#34;請輸入顧客的城市：\u0026#34;) # 3. 輸出顧客的所有資訊 print(\u0026#34;\\n顧客的所有資訊：\u0026#34;) print(customer) # 4. 該字典目前包含多少組 key:value print(\u0026#34;\\n字典中的 key:value 組數：\u0026#34;, len(customer)) # 5. 顧客搬家了，將顧客的城市更新為 \u0026#34;Taipei\u0026#34; customer[\u0026#34;city\u0026#34;] = \u0026#34;Taipei\u0026#34; print(\u0026#34;\\n更新後的顧客資訊：\u0026#34;, customer) print(customer) # 6. 移除顧客的性別資訊 customer.pop(\u0026#34;gender\u0026#34;) print(\u0026#34;\\n移除性別後的顧客資訊：\u0026#34;) print(customer) 請輸入顧客的姓名：dac\n請輸入顧客的性別：male\n請輸入顧客的年齡：4\n請輸入顧客的城市：tainan\n顧客的所有資訊：\n{\u0026rsquo;name\u0026rsquo;: \u0026lsquo;dac\u0026rsquo;, \u0026lsquo;gender\u0026rsquo;: \u0026lsquo;male\u0026rsquo;, \u0026lsquo;age\u0026rsquo;: 4, \u0026lsquo;city\u0026rsquo;: \u0026rsquo;tainan\u0026rsquo;}\n字典中的 key:value 組數： 4\n更新後的顧客資訊：\n{\u0026rsquo;name\u0026rsquo;: \u0026lsquo;dac\u0026rsquo;, \u0026lsquo;gender\u0026rsquo;: \u0026lsquo;male\u0026rsquo;, \u0026lsquo;age\u0026rsquo;: 4, \u0026lsquo;city\u0026rsquo;: \u0026lsquo;Taipei\u0026rsquo;}\n移除性別後的顧客資訊：\n{\u0026rsquo;name\u0026rsquo;: \u0026lsquo;dac\u0026rsquo;, \u0026lsquo;age\u0026rsquo;: 4, \u0026lsquo;city\u0026rsquo;: \u0026lsquo;Taipei\u0026rsquo;}\n數值和關係運算子 Python 支援各種數值運算，這些運算能夠處理整數和浮點數等數字型態。\n數值運算子 1 2 3 4 5 6 7 8 9 10 a = 10 b = 3 print(a + b) # 加法 print(a - b) # 減法 print(a * b) # 乘法 print(a / b) # 除法 print(a // b) # 取整除 print(a % b) # 取餘數 print(a ** b) # 次方 13\n7\n30\n3.3333333333333335\n3\n1\n1000\n關係運算子 關係運算子用於比較兩個數值或變數，結果會返回布林值 1 2 3 4 5 6 7 8 9 x = 10 y = 20 print(x == y) # 等於 print(x != y) # 不等於 print(x \u0026gt; y) # 大於 print(x \u0026lt; y) # 小於 print(x \u0026gt;= y) # 大於或等於 print(x \u0026lt;= y) # 小於或等於 False\nTrue\nFalse\nTrue\nFalse\nTrue\n複合指定運算子 複合指定運算子就是為簡化此種敘述產生的運算子，將運算子置於「=」前方來取代重複的變數名稱。 複合指定運算子同時做了「執行運算」及「指定」兩件工件 1 2 3 4 i=10 i+=5 #即 i=i+5 print(i) 15\n數值運算與關係運算的綜合應用 在實際應用中，常常會將數值運算與關係運算結合起來，對數據進行條件判斷。\n1 2 3 4 5 6 7 8 9 10 # 檢查一個數字是否是偶數 num = 10 is_even = (num % 2 == 0) # 使用取餘數來判斷是否為偶數 print(f\u0026#34;{num} 是偶數嗎？{is_even}\u0026#34;) # 比較兩個數字的大小 a = 5 b = 7 result = (a + 3 \u0026gt; b) # 進行數學運算後比較 print(f\u0026#34;a + 3 是否大於 b？{result}\u0026#34;) 數值和關係運算綜合練習 BMI（Body Mass Index）是一個常見的健康指標，用來衡量一個人的體重是否在正常範圍內。\n1 2 3 4 5 6 7 # 輸入身高和體重 weight = float(input(\u0026#34;請輸入你的體重（公斤）：\u0026#34;)) height = float(input(\u0026#34;請輸入你的身高（公尺）：\u0026#34;)) # 計算 BMI bmi = weight / (height ** 2) print(\u0026#34;你的 BMI 是：\u0026#34;, bmi) 邏輯判斷 邏輯運算子 Python 中有三個主要的邏輯運算子，它們用來處理布林值並進行邏輯判斷： 1 2 3 4 5 6 a = True b = False print(a and b) # False print(a or b) # True print(not a) # False 1 2 3 4 5 6 7 8 a = 3 # 宣告變數a為3，此式不會有產出 print((a \u0026gt; 1) and (a \u0026lt; 5)) #True and True print((a \u0026gt; 1) and (a \u0026gt; 5)) #True and False print((a \u0026lt; 1) and (a \u0026gt; 5)) #False and False print((a \u0026gt; 1) or (a \u0026lt; 5)) #True or True print((a \u0026gt; 1) or (a \u0026gt; 5)) #True or False print((a \u0026lt; 1) or (a \u0026gt; 5)) #False or False print(not(a \u0026gt; 1)) #NOT True If-Else條件判斷 if 用來檢查一個條件，如果該條件為 True，就會執行對應的程式碼。 elif（else if）用來檢查另一個條件（當前面的條件不成立時）。 else 當所有條件都不成立時，執行預設的動作。 1 2 3 4 5 #if price = 120 if price \u0026lt; 200 : print(\u0026#39;錢夠購買\u0026#39;) #因為目前的price小於200元，所以會執行if這一行程式 錢夠購買\n1 2 3 4 5 6 7 #if－else student = 80 if student \u0026lt;= 70 : print(\u0026#39;可以加簽\u0026#39;) else: print(\u0026#39;人數已滿\u0026#39;) 人數已滿\n1 2 3 4 5 6 7 8 9 #if-elif-else temperature = 36.2 if temperature \u0026lt;=37 : print(\u0026#39;體溫正常\u0026#39;) elif 37.5 \u0026lt;= temperature \u0026lt;38 : print(\u0026#39;輕微發燒\u0026#39;) else : print(\u0026#39;發燒\u0026#39;) 體溫正常\n多條件判斷 當兩個條件同時成立時，使用 and。 當其中任一條件成立時，使用 or。 1 2 3 4 5 6 age = int(input(\u0026#34;請輸入你的年齡：\u0026#34;)) if age \u0026gt;= 18 and age \u0026lt; 65: print(\u0026#34;你是工作年齡段\u0026#34;) elif age \u0026gt;= 65 or age \u0026lt; 18: print(\u0026#34;你不是工作年齡段\u0026#34;) 請輸入你的年齡：23\n你是工作年齡段\n巢狀條件判斷 巢狀條件判斷允許我們在某些條件成立時進一步檢查更多條件。這在處理多層次的邏輯時非常有用。\n1 2 3 4 5 6 7 8 9 10 score = int(input(\u0026#34;請輸入你的分數：\u0026#34;)) if score \u0026gt;= 60: print(\u0026#34;恭喜，你及格了！\u0026#34;) if score \u0026gt;= 90: print(\u0026#34;而且你是高分！\u0026#34;) else: print(\u0026#34;不過你還可以努力獲得更高分！\u0026#34;) else: print(\u0026#34;抱歉，你沒有及格。\u0026#34;) 條件表達式（三元運算子） 條件表達式允許我們在一行中寫出簡單的條件判斷 用法: 值1 if 條件 else 值2 1 2 3 age = int(input(\u0026#34;請輸入你的年齡：\u0026#34;)) status = \u0026#34;成年人\u0026#34; if age \u0026gt;= 18 else \u0026#34;未成年人\u0026#34; print(status) 請輸入你的年齡：24\n成年人\n邏輯判斷綜合練習 調酒推薦系統\n設計一個簡單的「調酒推薦系統」，根據使用者的口味偏好，推薦一款適合的調酒：\n使用者會回答三個問題來表達他們的口味偏好：\n基酒選擇：Gin、Whiskey、Vodka 酒感：輕 or 重 根據這三個問題的回答，推薦以下調酒： Gin Tonic：gin/輕 Old Fashioned：whiskey/重 Cosmopolitan：vodka/輕 Whiskey Sour：whiskey/輕 Vodka Martini：vodka/重 Negroni：gin/重 系統根據使用者的選擇推薦合適的調酒。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 1. 問使用者的偏好 base_liquor = input(\u0026#34;你想要選擇的基酒是什麼？（gin/whiskey/vodka）：\u0026#34;).strip().lower() strength = input(\u0026#34;你喜歡酒感輕還是重？（輕/重）：\u0026#34;).strip() # 2. 根據偏好進行推薦 if base_liquor == \u0026#34;gin\u0026#34; and strength == \u0026#34;輕\u0026#34;: print(\u0026#34;我們推薦：Gin Tonic（琴通寧）\u0026#34;) elif base_liquor == \u0026#34;gin\u0026#34; and strength == \u0026#34;重\u0026#34;: print(\u0026#34;我們推薦：Negroni（尼格羅尼）\u0026#34;) elif base_liquor == \u0026#34;whiskey\u0026#34; and strength == \u0026#34;輕\u0026#34;: print(\u0026#34;我們推薦：Whiskey Sour（威士忌酸酒）\u0026#34;) elif base_liquor == \u0026#34;whiskey\u0026#34; and strength == \u0026#34;重\u0026#34;: print(\u0026#34;我們推薦：Old Fashioned（舊式雞尾酒）\u0026#34;) elif base_liquor == \u0026#34;vodka\u0026#34; and strength == \u0026#34;輕\u0026#34;: print(\u0026#34;我們推薦：Cosmopolitan（柯夢波丹）\u0026#34;) elif base_liquor == \u0026#34;vodka\u0026#34; and strength == \u0026#34;重\u0026#34;: print(\u0026#34;我們推薦：Moscow Mule（莫斯科騾子）\u0026#34;) else: print(\u0026#34;無法提供推薦，請檢查您的輸入。\u0026#34;) Try-Except-Finally Try-Except 在發生錯誤時提供提示，而不是讓程式崩潰\nPython常見的錯誤類型:\nZeroDivisionError：除以零的錯誤。 ValueError：當變量的類型不符合操作時，例如試圖將字串轉換為數字。 TypeError：當不同類型之間進行非法操作時。 IndexError：當試圖訪問超出範圍的列表索引時。 KeyError：當在字典中查找不存在的鍵時。 1 2 3 4 5 # 基本語法結構： try: # 可能會發生錯誤的code except: # 如果發生錯誤，這裡的code會被執行 1 2 3 4 5 6 7 8 try: number = int(input(\u0026#34;請輸入一個數字：\u0026#34;)) result = 10 / number print(f\u0026#34;結果是：{result}\u0026#34;) except ZeroDivisionError: print(\u0026#34;錯誤：除數不能為 0\u0026#34;) except ValueError: print(\u0026#34;錯誤：請輸入有效的數字\u0026#34;) 請輸入一個數字：0\n錯誤：除數不能為 0\nfinally - 確保一定會執行的代碼 finally 區塊中的code無論是否發生錯誤都會被執行，用於釋放資源或清理工作。\n1 2 3 4 5 6 try: # 嘗試執行的code except: # 處理錯誤 finally: # 總是會執行的code 1 2 3 4 5 6 7 8 9 10 11 12 try: # 嘗試進行簡單的除法運算 num1 = float(input(\u0026#34;請輸入第一個數字：\u0026#34;)) num2 = float(input(\u0026#34;請輸入第二個數字：\u0026#34;)) result = num1 / num2 print(f\u0026#34;結果是：{result}\u0026#34;) except ZeroDivisionError: print(\u0026#34;錯誤：除數不能為 0\u0026#34;) except ValueError: print(\u0026#34;錯誤：請輸入有效的數字\u0026#34;) finally: print(\u0026#34;無論是否發生錯誤，這段代碼都會執行。謝謝使用\u0026#34;) 請輸入第一個數字：cool\n錯誤：請輸入有效的數字\n無論是否發生錯誤，這段代碼都會執行。謝謝使用\n迴圈 For Loop for 迴圈用於遍歷序列（如列表、字串或範圍）。每次迴圈執行時，會依次取得序列中的每個元素，直到所有元素都被處理完畢。\n基本語法：\n1 2 for 變數 in 序列: # 要執行的code 1 2 3 4 fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for i in fruits: print(i) 一個裝有水果名稱的列表 [\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;cherry\u0026rdquo;]。我們希望能夠一次輸出這些水果的名稱。\ni就是迴圈中的一個臨時變數。每次迴圈從 fruits 列表中取出一個水果，把這個水果的值存進 i 這個變數裡，然後印出來。第一圈時，fruit 是 \u0026ldquo;apple\u0026rdquo;，第二圈時是 \u0026ldquo;banana\u0026rdquo;，最後一圈是 \u0026ldquo;cherry\u0026rdquo;。\n1 2 3 4 word = \u0026#34;python\u0026#34; for letter in word: #這邊letter 使用 i 也可以 print(letter) p\ny\nt\nh\no\nn\n1 2 3 4 5 for i in range(5): # 產生 0 到 4 的數字 print(i) # 告訴迴圈，對於 range(5) 生成的每一個數字，都把它賦值給 i，然後印出來。 # 所以這個程式會從 0 一直印到 4。 0\n1\n2\n3\n4\n巢狀迴圈 Nested For Loop aka For loop 中還有 For loop\n1 2 3 4 5 6 7 sum = 0 for n in range(10, 20): for z in range(2,3): result = n + z print(f\u0026#39;{n} + {z} = {result}\u0026#39;) # 列出每個 n + z 的結果 sum += result print(\u0026#39;數列總和為:\u0026#39;, sum) # 最後列出 sum 的總和 10 + 2 = 12\n11 + 2 = 13\n12 + 2 = 14\n13 + 2 = 15\n14 + 2 = 16\n15 + 2 = 17\n16 + 2 = 18\n17 + 2 = 19\n18 + 2 = 20\n19 + 2 = 21\n數列總和為: 165\n99乘法表\n1 2 3 4 5 # 99 乘法表 for i in range(1, 10): # 外層迴圈，控制乘數 for j in range(1, 10): # 內層迴圈，控制被乘數 print(f\u0026#34;{i} * {j} = {i * j}\u0026#34;, end=\u0026#34;\\t\u0026#34;) print() # 換行 For Loop進階應用- Break 如果有東西在for loop計算過程中已經滿足了，可以提前結束迴圈 例如，找資料、計算目標答案等，不想看到7的99乘法表 1 2 3 4 5 6 7 # 99 乘法表 for i in range(1, 10): # 外層迴圈，控制乘數 for j in range(1, i + 1): # 內層迴圈，控制被乘數 if j \u0026gt; 6: # 當被乘數大於6時，跳出內層迴圈 break print(f\u0026#39;{j} * {i} = {i * j}\u0026#39;, end=\u0026#39;\\t\u0026#39;) print() For Loop進階應用- Continue 當你的 for loop 要 skip 某些東西的時候可以用\n1 2 3 4 5 6 7 # 99 乘法表 for i in range (60): if i % 2==0: continue print(i,end=\u0026#39;,\u0026#39;) # 當 i 是偶數時，我們跳過印出的動作，這樣就只會印出奇數。 1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,\nWhile Loop while 迴圈的作用是「當某個條件成立的時候，就一直進行某種操作」。\n這個條件必須是一個布林值（True 或 False），當條件變為 False 時，while 迴圈就會停止，不再繼續執行。也就是說，while 迴圈每次運行都會先檢查這個條件，只有當條件為 True 時，才會進入迴圈，否則就跳過它。\n一定要確定會停止!!!避免無窮迴圈!!!\n基本語法：\n1 2 while 條件(只有True/False): # 要執行的code 1 2 3 4 5 count = 0 while count \u0026lt; 5: print(f\u0026#34;目前計數：{count}\u0026#34;) count += 1 目前計數：0\n目前計數：1\n目前計數：2\n目前計數：3\n目前計數：4\n設定了一個變數 count，初始值是 0。然後我們告訴程式：只要 count 小於 5，就一直執行 while 迴圈，並且每次執行時，count 的值會自動增加 1。當 count 到達 5 時，條件變成 False，迴圈就停止了。\nWhile Loop進階應用 break：提前結束迴圈 當迴圈中遇到break時，迴圈會立刻結束，並跳出迴圈的執行。\ncontinue：跳過本次迴圈，進入下一次迴圈 當迴圈中遇到continue時，會跳過本次迴圈的剩餘部分，直接進入下一次迴圈。\n1 2 3 4 5 6 7 # break number = 0 while number \u0026lt; 10: if number == 5: break # 遇到數字 5 時終止迴圈 print(number) number += 1 0\n1\n2\n3\n4\n5\n這個程式會從 0 開始計數，當 number 遞增到 5 時，if 條件會成立，執行 break，結束迴圈。你會看到迴圈並沒有執行到 9，就在 number 等於 5 的時候停止了。\n1 2 3 4 5 6 7 8 # continue number = 0 while number \u0026lt; 5: if number == 2: number += 1 # 注意：在 continue 前必須手動更新 number，避免無限迴圈 continue # 當數字是 2 時跳過這次迴圈 print(number) number += 1 0\n1\n3\n4\n每次執行時，當 number 等於 2 時會跳過當前迭代，並且直接進入下一次迴圈。你會發現 2 並沒有被印出來，因為在 continue 之後，print() 就不會被執行了。\nLoop 課堂練習1 練習利用迴圈來計算 n!總和\n輸入:任意數字n 輸出:n!的結果 階乘定義：\n階乘（factorial）是所有從 1 到 n 的整數相乘的結果，記作 n!。 例如：5! = 5 * 4 * 3 * 2 * 1 = 120 注意：0! = 1 1 2 3 4 5 6 7 8 9 10 11 n = int(input(\u0026#34;請輸入 n: \u0026#34;)) factorial = 1 count = 1 # 使用 while 迴圈計算 n! while count \u0026lt;= n: factorial *= count count += 1 # 輸出結果 print(f\u0026#34;{n}! = {factorial}\u0026#34;) 請輸入 n: 7\n7! = 5040\nfactorial 是用來存放最終的階乘結果，並且我們每次都讓它乘以目前的 count 值。 當 count 小於等於 n 時，我們就一直運算，直到 count 大於 n 為止。 Loop 課堂練習2 數字猜猜樂\n設計一個數字猜測遊戲，要求如下：\n電腦會隨機生成一個 1 到 100 的數字。 使用者最多可以猜測 5 次。 每次猜測時，電腦會提示數字是「太大了」或「太小了」。 如果使用者猜對了，遊戲立即結束並顯示「猜對了！」。 如果 5 次都沒猜對，顯示正確答案並結束遊戲。 hint: 生成隨機數可用套件random\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import random # 1. 生成隨機數 secret_number = random.randint(1, 100) # 2. 最多猜 5 次 for attempt in range(1, 6): # 3. 提示使用者輸入數字 guess = int(input(f\u0026#34;請輸入你的猜測（第 {attempt} 次，1-100）：\u0026#34;)) # 4. 使用 while 檢查是否輸入有效範圍內的數字 while guess \u0026lt; 1 or guess \u0026gt; 100: print(\u0026#34;數字必須在 1 到 100 之間！\u0026#34;) guess = int(input(f\u0026#34;請重新輸入你的猜測（第 {attempt} 次，1-100）：\u0026#34;)) # 5. 比較使用者的猜測與隨機數 if guess \u0026lt; secret_number: print(\u0026#34;太小了！\u0026#34;) elif guess \u0026gt; secret_number: print(\u0026#34;太大了！\u0026#34;) else: print(f\u0026#34;恭喜你猜對了！答案是 {secret_number}\u0026#34;) break # 結束迴圈 else: # 如果 5 次內沒猜對 print(f\u0026#34;很遺憾，正確答案是 {secret_number}\u0026#34;) random.randint(1, 100) 用來生成一個隨機的數字，並儲存在變數 secret_number 中。 使用 for 迴圈來限制猜測次數，最多只能猜 5 次。 每次猜測後，會比較你輸入的數字和 secret_number 的大小，並且提供「太大了」或「太小了」的提示。 如果猜對了，就會跳出迴圈，並告訴正確答案；如果 5 次內沒猜中，則顯示正確答案。 函數def 函數是一段可以重複執行的程式碼，透過一個名稱來呼叫他，就不用重複寫同樣的程式碼。函數可以接收輸入（參數），並在執行後回傳結果。\n函數的主要優點是可以讓程式更具結構性、可讀性，並減少重複程式碼。\nQ: 為什麼要使用函數？\n減少重複：可以避免多次書寫相同的程式碼。 提高可讀性：讓程式結構更加清晰明瞭。 便於修改和擴展：當函數內部邏輯變更時，只需修改一處，不需要在程式中的每個地方進行更改。 基本函數 函數的基本語法結構：\n1 2 3 def 函數名稱(參數1,參數2,...): # 函數內容 return 回傳值 範例1\n1 2 3 4 5 6 def say_hello(): print(\u0026#34;Hello, 你好!\u0026#34;) say_hello() # 這是一個不需要參數的函數，只要呼叫它，就會執行其中的程式碼 Hello, 你好!\n帶有參數的函數 函數可以接收參數，這些參數就像是給函數的額外資訊，來讓它執行不同的任務，可以讓函數變得更加靈活\n1 2 3 4 def greet(name): print(f\u0026#34;Hello, {name}! 你好！\u0026#34;) greet(\u0026#34;DAC\u0026#34;) Hello, DAC! 你好！\n函數 greet() 接收一個參數 name，當呼叫 greet(\u0026ldquo;Stan\u0026rdquo;) 時，我們把 \u0026ldquo;Stan\u0026rdquo; 作為參數傳遞給函數，\n函數內的程式碼 print(f\u0026quot;Hello, {name}! 你好！\u0026quot;) 就會執行，結果會輸出 Hello, Stan! 你好！\n返回值 (return) 函數執行後可以透過 return 將結果返回，讓呼叫該函數的地方得到結果。return 後的程式碼不會再執行。\n1 2 3 4 5 def add(x, y): return x + y result = add(5, 10) print(result) 15\n函數 add(x, y) 接收兩個參數 x 和 y，它將這兩個參數加在一起，並透過 return 返回結果。\n當我們呼叫 add(5, 10) 時，Python會將5 和 10傳遞給 x 和 y，然後計算出 5 + 10 = 15，並將結果儲存在 result 中，最後輸出結果。\n1 2 3 4 5 def square(number): return number * number result = square(35) print(result) 1225\ndef square(number)：定義了一個函數 square，它接收一個參數 number。 return number * number：這個 return 語句將 number * number 的計算結果返回。比如當 number = 5 時，5 * 5 = 25，這個結果會被返回。 result = square(5)：呼叫函數 square(5)，並將返回的結果（即 25）存儲到變數 result 中。 print(result)：最後，print 會輸出 result，即 25。 1 2 3 4 5 6 7 def calculate_square_and_cube(number): square = number * number cube = number * number * number return square, cube result_square, result_cube = calculate_square_and_cube(3) print(f\u0026#34;平方是: {result_square}, 立方是: {result_cube}\u0026#34;) 平方是: 9, 立方是: 27\n無返回值 如果函數內沒有 return ，或者沒有指定返回值，函數會默認返回 None。\n1 2 3 4 5 def say_hello(): print(\u0026#34;Hello!\u0026#34;) result = say_hello() print(result) Hello! None\ndef say_hello()：這裡定義了一個沒有參數的函數 say_hello。 print(\u0026ldquo;Hello!\u0026quot;)：這個函數只做一件事情，就是輸出 \u0026ldquo;Hello!\u0026quot;。它不會返回任何值。 result = say_hello()：呼叫函數 say_hello()，因為這個函數沒有返回值，所以 result 會儲存為 None。 print(result)：最後，print(result) 會輸出 None，因為函數 say_hello() 並沒有返回任何東西。 def 課堂練習 簡單計算器 需求：\n請定義一個函數 calculator，該函數接收兩個數字和一個運算符號（+, -, *, /），並根據運算符號進行對應的計算。 使用者透過 input() 函數輸入兩個數字和運算符號，然後呼叫 calculator 函數來進行計算。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def calculator(num1, num2, operator): if operator == \u0026#34;+\u0026#34;: return num1 + num2 elif operator == \u0026#34;-\u0026#34;: return num1 - num2 elif operator == \u0026#34;*\u0026#34;: return num1 * num2 elif operator == \u0026#34;/\u0026#34;: if num2 != 0: return num1 / num2 else: return \u0026#34;錯誤: 除數不能為 0\u0026#34; else: return \u0026#34;無效的運算符號\u0026#34; # 使用者輸入 num1 = float(input(\u0026#34;請輸入第一個數字: \u0026#34;)) num2 = float(input(\u0026#34;請輸入第二個數字: \u0026#34;)) operator = input(\u0026#34;請輸入運算符號 (+, -, *, /): \u0026#34;) # 呼叫函數進行計算並輸出結果 result = calculator(num1, num2, operator) print(f\u0026#34;計算結果是: {result}\u0026#34;) ","date":"2024-10-18T00:00:00Z","image":"https://KathyKo.github.io/p/python-basic/python%20basic_hu11626036041438369366.png","permalink":"https://KathyKo.github.io/p/python-basic/","title":"Python Basic For Everyone"},{"content":"Text-to-SQL is a task in natural language processing (NLP) where the goal is to automatically generate SQL queries from natural language text. The task involves converting the text input into a structured representation and then using this representation to generate a semantically correct SQL query that can be executed on a database.\n","date":"2024-06-06T00:00:00Z","image":"https://KathyKo.github.io/p/text2sql/text2sql_hu9177949317969933240.png","permalink":"https://KathyKo.github.io/p/text2sql/","title":"Text to SQL"},{"content":"Introducing WrenAI Support with popular databases, data warehouses, and analytics tools!\nAbout WrenAI Interactive Experience: Designed to engage users in a dialogue, clarifying queries and refining results in real time. This interactivity ensures that the generated SQL queries accurately reflect the user\u0026rsquo;s intent, making the data querying process more intuitive and user-friendly. Explainability: It ensures every SQL query generated in natural language is accurate, concise, and reliable. Interoperability: It enables users to query data from multiple sources without dealing with the complexities of different data formats and dialects, providing a standard interface across different sources. How WrenAI works? WrenAI is consist of three core services\nWren UI: An intuitive user interface for asking questions, defining data relationships, and integrating data sources within WrenAI\u0026rsquo;s framework. Wren AI Service: Processes queries using a vector database for context retrieval, guiding LLMs to produce precise SQL outputs. Wren Engine: Serves as the platform\u0026rsquo;s backbone, managing metadata and connecting to data sources, while preparing for future application integrations. Getting Start! Installation Prerequisites\nInstall Docker Desktop on local computer Prepare an OpenAI API key Using WrenAI Launcher\nMac OSX Execute following commands in the terminal 1 curl -L https://github.com/Canner/WrenAI/releases/latest/download/wren-launcher-darwin.tar.gz | tar -xz \u0026amp;\u0026amp; ./wren-launcher-darwin Run the program Enter OpenAI API key Wait for the installation to finish. Program will setup docker containers for you and open the application URL in the browser for you after installation. Open localhost:3000 to start using if the launcher program doesn\u0026rsquo;t open the URL Start with sample data Wren AI offers 2 sample datasets:\nE-commerce NBA (2022 NBA playoff games) Take E-commerce dataset for example to show following steps:\nClick on the E-commerce option Ask a question Ask any questions related to the dataset, Wren AI will provide 1~3 results from the dataset that best answer the question. (a) Try a sample question: Choose \u0026ldquo;What is the average score of reviews submitted for orders placed by customers in each city?\u0026rdquo; (b)Choose a Result (c) View the SQL plan description, data preview and the SQL statements in each step based on the selected result ","date":"2024-05-02T00:00:00Z","image":"https://KathyKo.github.io/p/wren-ai/wrenai_hu4653357968861513781.png","permalink":"https://KathyKo.github.io/p/wren-ai/","title":"Wren AI"},{"content":"Introduction What is Flowise? Flowise uses low-code approach that enable developers to manage the whole lifecycle of building LLMs apps in production. From protoyping, evaluation, to iterations.\nBuilt on the foundation of LangChain.js, Flowise offers advanced features to enhance the development process. From LLM orchestration and agent creation to seamless integration via APIs, SDKs, and Embedded Chat, Flowise provides a comprehensive toolkit for building dynamic AI-driven solutions.\nKey Features of Flowise LLM Orchestration: Seamlessly connect LLMs with various components such as memory, data loaders, cache, and moderation tools. Agents \u0026amp; Companions: Develop autonomous agents capable of executing diverse tasks. API, SDK, Embed: Extend functionality and integrate with existing applications through APIs, SDKs, and Embedded Chat. Open Source LLMs: Run applications in air-gapped environments with local LLMs, embeddings, and vector databases. Supported LLM Frameworks: LangChain LlamaIndex Getting Started Prerequisite Latest (NodeJS)installed\n⚡ Quick Start Install Flowise 1 npm install -g flowise Start Flowise 1 npx flowise start Open http://localhost:3000 in the browser. Enter npm update -g flows to update to latest version!\nBuild your first app Create new chat flow by clicking on Add New and this will give us blank canva where we can create an AI application. ","date":"2024-04-20T00:00:00Z","image":"https://KathyKo.github.io/p/flowsie-ai/flowise_hu2675251105199535852.png","permalink":"https://KathyKo.github.io/p/flowsie-ai/","title":"Flowise AI"},{"content":"Introduction What is PartyRock? Amazon PartyRock is an environment that allows users to experiment with and build generative AI-powered applications without any coding, focusing on skills like prompt engineering. It’s a fast and fun way to learn about generative AI 🕹️\nHow to use AWS PartyRock? How does it works? PartyRock uses foundation models from Amazon Bedrock to turn your ideas into working PartyRock apps. The platform then uses this description to create the application, providing widgets and tools based on the entered prompt. To get the most out of the PartyRock experience, you can do the following:\nGet started by creating a PartyRock app. Build the app by editing UI elements called widgets. You can change widget prompts so that they connect to each other and accomplish different things. Take the next steps and publish your PartyRock app and share it with others. Building the app How does the PartyRock create an app? The app builder is a generative AI tool within PartyRock that can make different apps for you through a process called inference.\nApp Creation: PartyRock uses a generative AI tool to create applications based on user descriptions, leveraging Amazon Bedrock\u0026rsquo;s foundation models. Widget Assembly: It generates instructions for app construction, detailing necessary components and UI elements like text boxes and buttons. Customization: In the app editor, users can customize by adjusting widget sizes positions, and functions to fulfill the intended app purpose. What is a widget? Widgets in PartyRock are UI elements that can interact, display content, and process input. They can be linked to create complex outputs, like text or images, using AI-driven prompts and data from other widgets. These AI-powered widgets leverage foundation models for content generation.\nTypes of widgets 3 AI-powered widgets: Image generation, Chatbot, and Text generation. You can edit AI-powered widgets to connect them to other widgets and make their output change. 2 other widgets: User input and Static text. The user input widget allow users to change output when you connect it to AI-powered widgets. The static text widget provides a place for text descriptions. Let's start! Enter the prompt Enter the prompt that you want your app to do\nAfter entering the prompt and clicking \u0026lsquo;Create\u0026rsquo;, you will receive an initial simple app.\nSettings Each widget can be resized and repositioned freely; clicking the settings button in the top right corner allows for editing and configuring options such as widget name, model used, temperature, etc.\nAlso, you can click the \u0026lsquo;Create Widget\u0026rsquo; on the canva to create new widgets.\nI putted @Workout Duration into the prompt, allowing the LLM to dynamically read the user\u0026rsquo;s input. Additionally, I set the temp to 0.5, hoping to maintain a certain degree of flexibility in the LLM\u0026rsquo;s responses.\nWhat is temperature? A setting used to control the randomness of the responses generated by the model. Low Temperature (e.g., closer to 0): The AI\u0026rsquo;s responses are more predictable,confident, and less varied. The model sticks closely to the most likely words and phrases based on its training. High Temperature (e.g., closer to 1): The AI\u0026rsquo;s responses are more random and diverse. It might produce more creative or unusual outputs, as it’s more willing to choose less likely words and phrases. Why use temperature? Temperature allows you to balance between creativity and accuracy. Adjusting the temperature setting in an AI model helps to tune how \u0026ldquo;safe\u0026rdquo; or \u0026ldquo;adventurous\u0026rdquo; the AI\u0026rsquo;s responses should be, depending on what you need it for. After completing the edits, you can click Make Public and Share in the top right corner of the page to publish your created app!\n","date":"2024-04-02T00:00:00Z","image":"https://KathyKo.github.io/p/partyrock/cover_hu6689909693033042109.png","permalink":"https://KathyKo.github.io/p/partyrock/","title":"AWS PartyRock"},{"content":"Introduction Google Cloud Document AI API and Google Cloud Vision API are both Google Cloud services designed for processing documents and images.\n1.Document Processing:\nDocument AI API:\nDocument AI API focuses on processing structured documents, such as PDFs and OCR documents. Its primary functionalities include text extraction, table recognition page identification, entity recognition (e.g., identifying dates and amounts in contracts), and more. This makes it suitable for handling business documents like contracts, invoices, reports, and others. Vision API: Vision API specializes in processing images and pictures. It can recognize objects, faces, scenes, text, and more within images. Its main applications include image classification, facial recognition, OCR text recognition, and more. This makes it suitable for image processing applications like image search, facial recognition, and automated image analysis. 2.Application Scenario:\nDocument AI API: The Document AI API is suitable for business scenarios that involve processing a large volume of structured documents, such as contracts, invoices, and medical records. Vision API: The Vision API is well-suited for applications that require processing images and photos, such as image analysis and image search. Code Demo ☁️ Cloud Vision\nRecognize text in pictures 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #Detect online images from google.cloud import vision def detect_document_text_uri(uri): \u0026#34;\u0026#34;\u0026#34;Detects document text in the file located in Google Cloud Storage or on the Web.\u0026#34;\u0026#34;\u0026#34; client = vision.ImageAnnotatorClient() image = vision.Image() image.source.image_uri = uri response = client.document_text_detection(image=image) document = response.full_text_annotation print(document.text) if response.error.message: raise Exception( \u0026#34;{}\\nFor more info on error messages, check: \u0026#34; \u0026#34;https://cloud.google.com/apis/design/errors\u0026#34;.format(response.error.message) ) detect_document_text_uri(\u0026#39;https://i.redd.it/2aby2h2mhtpb1.jpg\u0026#39;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #Detect local images def detect_text(path): \u0026#34;\u0026#34;\u0026#34;Detects text in the file.\u0026#34;\u0026#34;\u0026#34; from google.cloud import vision client = vision.ImageAnnotatorClient() with open(path, \u0026#34;rb\u0026#34;) as image_file: content = image_file.read() image = vision.Image(content=content) response = client.text_detection(image=image) texts = response.text_annotations if texts: print(texts[0].description) detect_text(\u0026#34;profile path\u0026#34;) Click ▶ to expand the examples\nExample \u0026 Result (online images) Example \u0026 Result (local images) Recognize handwriting in pictures 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #Detect text in online images def detect_document_uri(uri): \u0026#34;\u0026#34;\u0026#34;Detects document features in the file located at the given URL.\u0026#34;\u0026#34;\u0026#34; from google.cloud import vision_v1 client = vision_v1.ImageAnnotatorClient() image = vision_v1.Image() image.source.image_uri = uri response = client.document_text_detection(image=image) for page in response.full_text_annotation.pages: for block in page.blocks: for paragraph in block.paragraphs: for word in paragraph.words: word_text = \u0026#34;\u0026#34;.join([symbol.text for symbol in word.symbols]) print(word_text) if response.error.message: raise Exception( \u0026#34;{}\\nFor more info on error messages, check: \u0026#34; \u0026#34;https://cloud.google.com/apis/design/errors\u0026#34;.format(response.error.message) ) detect_document_uri(\u0026#39;https://ocr-demo.abtosoftware.com/uploads/handwritten3.jpg\u0026#39;) Example \u0026 Result (local images) Example \u0026 Result (online images) 📃 Document AI\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from typing import Optional from google.api_core.client_options import ClientOptions from google.cloud import documentai def process_document_sample() -\u0026gt; None: # Specify Google Cloud ID \u0026amp; other parameters project_id = \u0026#34;your project id\u0026#34; location = \u0026#34;us\u0026#34; processor_id = \u0026#34;your processor id\u0026#34; mime_type = \u0026#34;application/pdf\u0026#34; field_mask = \u0026#34;text,entities,pages.pageNumber\u0026#34; processor_version_id = None # Do not use a specific processor version #Input file path file_path = input(\u0026#34;Please enter the path to the PDF file you want to process: \u0026#34;) # Initialize Document AI client client = documentai.DocumentProcessorServiceClient() if processor_version_id: name = client.processor_version_path( project=project_id, location=location, processor=processor_id, processor_version=processor_version_id ) else: name = client.processor_path(project=project_id, location=location, processor=processor_id) with open(file_path, \u0026#34;rb\u0026#34;) as image: image_content = image.read() raw_document = documentai.RawDocument(content=image_content, mime_type=mime_type) request = documentai.ProcessRequest( name=name, raw_document=raw_document, field_mask=field_mask ) result = client.process_document(request=request) document = result.document print(document.text) if __name__ == \u0026#34;__main__\u0026#34;: process_document_sample() Through exploring these APIs, I learned about their specific applications in handling structured documents and images, and the potential for automating tasks in business and image analysis contexts. Looking ahead, these insights could be applied in developing more efficient document management systems, enhancing data extraction from documents, and improving image-based search and analysis in various industries.\n","date":"2023-10-02T00:00:00Z","image":"https://KathyKo.github.io/p/test/cover_hu13415283376427659439.jpg","permalink":"https://KathyKo.github.io/p/test/","title":"Google OCR"},{"content":"Conceptualization As an undergraduate student in the Taiwanese literature department, after completing the Introduction to Computing course, I began to contemplate how I could integrate coding skills with my major studies. Thus, I embarked on this small project, hoping to apply it within my field of study.\nUsers can choose from five songs to translate, allowing them to listen to music while learning Taiwanese simultaneously.\nCode UI Setting Using the Tkinter GUI toolkit to create the user interface.\n1 2 3 import tkinter as tk from tkinter import ttk import csv Designed a window with 400x400 and added a title label, using an EggplantEgg theme for the color scheme (purple-yellow-white). Set the font to Times New Roman.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class LyricsTranslatorApp: def __init__(self, root): self.root = root self.root.title(\u0026#34;茄子蛋台語歌翻譯器\u0026#34;) self.root.geometry(\u0026#39;400x400\u0026#39;) self.bg_image = tk.PhotoImage(file=\u0026#39;eggplant.png\u0026#39;) self.bg_label = tk.Label(root, image=self.bg_image) self.bg_label.place(relwidth=1, relheight=1) self.header_label = ttk.Label(root, text=\u0026#39;茄子蛋台語歌 歌詞翻譯器\u0026#39;, font=(\u0026#39;標楷體\u0026#39;, 18), foreground=\u0026#39;#592693\u0026#39;) self.header_label.grid(row=0, column=0, columnspan=2, pady=10) self.song_label = ttk.Label(root, text=\u0026#39;選擇歌曲：\u0026#39;, foreground=\u0026#39;#766592\u0026#39;) self.song_label.grid(row=1, column=0) self.song_combo = ttk.Combobox(root, state=\u0026#39;readonly\u0026#39;, width=40) self.song_combo.grid(row=1, column=1) self.result_button = ttk.Button(root, text=\u0026#39;確定\u0026#39;, command=self.load_lyrics) self.result_button.grid(row=2, column=1) self.combo_label1 = ttk.Label(root, text=\u0026#39;由\u0026#39;, foreground=\u0026#39;#766592\u0026#39;) self.combo_label1.grid(row=3, column=0) self.combo1 = ttk.Combobox(root, value=[\u0026#39;華語\u0026#39;, \u0026#39;台語\u0026#39;], state=\u0026#39;readonly\u0026#39;) self.combo1.grid(row=3, column=1) self.combo_label2 = ttk.Label(root, text=\u0026#39;轉\u0026#39;, foreground=\u0026#39;#766592\u0026#39;) self.combo_label2.grid(row=4, column=0) self.combo2 = ttk.Combobox(root, value=[\u0026#39;台語\u0026#39;, \u0026#39;華語\u0026#39;], state=\u0026#39;readonly\u0026#39;) self.combo2.grid(row=4, column=1) self.result_button2 = ttk.Button(root, text=\u0026#39;確定\u0026#39;, command=self.result) self.result_button2.grid(row=5, column=1) self.choose_label = ttk.Label(root, text=\u0026#39;選擇要翻譯的句子\u0026#39;, foreground=\u0026#39;#766592\u0026#39;) self.choose_label.grid(row=6, column=0, pady=(25, 0), columnspan=2) self.choose = None self.translate_button = ttk.Button(root, text=\u0026#39;確定\u0026#39;, command=self.translate) self.translate_button.grid(row=8, column=1, pady=10) self.result_label = ttk.Label(root, text=\u0026#39;翻譯結果\u0026#39;, foreground=\u0026#39;#766592\u0026#39;) self.result_label.grid(row=9, column=0, pady=10, columnspan=2) self.result_text = tk.StringVar() self.result_display = ttk.Label(root, textvariable=self.result_text, font=(\u0026#39;Times New Roman\u0026#39;, 12), foreground=\u0026#39;#766592\u0026#39;) self.result_display.grid(row=10, column=0, columnspan=2) When the user selects a song, the computer automatically reads the corresponding CSV file and stores the Chinese and Taiwanese content in two separate arrays.\nLanguage Translation Users can choose to translate from Chinese to Taiwanese or from Taiwanese to Chinese using a dropdown menu.\nBased on the selected translation direction, the range of choices is set using the contents of value1 and value2.\nAfter clicking the confirm button, a dropdown menu is generated to select the sentence to be translated.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def result(self): combo1_value = self.combo1.get() combo2_value = self.combo2.get() if combo1_value == \u0026#39;華語\u0026#39;: choices = self.value1 elif combo1_value == \u0026#39;台語\u0026#39;: choices = self.value2 else: return if self.choose: self.choose.destroy() self.choose = ttk.Combobox(root, value=choices, state=\u0026#39;readonly\u0026#39;, width=40) self.choose.grid(row=7, column=0, pady=(5, 0), columnspan=2) def translate(self): selected_lyrics = self.choose.get() if selected_lyrics: index = self.value1.index(selected_lyrics) if self.combo1.get() == \u0026#39;華語\u0026#39; else self.value2.index(selected_lyrics) taiwanese_lyrics = self.value2[index] if self.combo1.get() == \u0026#39;華語\u0026#39; else self.value1[index] self.result_text.set(taiwanese_lyrics) 1 2 3 4 5 6 7 8 if __name__ == \u0026#39;__main__\u0026#39;: root = tk.Tk() app = LyricsTranslatorApp(root) songs = [\u0026#39;浪流連\u0026#39;, \u0026#39;愛情你比我想的閣較偉大\u0026#39;, \u0026#39;閣愛妳一擺\u0026#39;, \u0026#39;這款自作多情\u0026#39;, \u0026#39;Happy!!! 運將情歌\u0026#39;] app.song_combo[\u0026#39;values\u0026#39;] = songs root.mainloop() After the user selects the sentence they wish to translate, the corresponding lyrics are located based on their choice and then translated. Depending on the chosen method of translation, the selected lyrics are translated and the results are displayed on the interface.\nWhile listening to the 2022 Golden Melody Awards Song of the Year, one can also take the opportunity to learn Romanized phonetics. This not only enhances understanding of the lyrics but also improves language skills and cultural knowledge 😊\n","date":"2021-04-10T00:00:00Z","image":"https://KathyKo.github.io/p/lyric-translator/egg_hu4033944038787135862.png","permalink":"https://KathyKo.github.io/p/lyric-translator/","title":"Taiwanese-Chinese Lyric Translator"}]